<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>UID Generator | 搜办小组</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="UID Generator为什么要使用由于 Event Soucing 是记录事件的，那么 Object Id 肯定就不能是用数据库生成的了，基本上所有的 Event Soucing 相关的框架都是将事件直接序列化，然后对应到 Object，所以这种情况下，就需要自己产生 ID，而自己生成 ID 的话，就有很多限制，比如需要根据时间递增，尽量比较短，在分布式的情况下 ID 保证不能重复等等，本文会">
<meta name="keywords" content="Event Sourcing,CQRS,UUID">
<meta property="og:type" content="article">
<meta property="og:title" content="UID Generator">
<meta property="og:url" content="http://yoursite.com/2019/06/10/UID-Generator/index.html">
<meta property="og:site_name" content="搜办小组">
<meta property="og:description" content="UID Generator为什么要使用由于 Event Soucing 是记录事件的，那么 Object Id 肯定就不能是用数据库生成的了，基本上所有的 Event Soucing 相关的框架都是将事件直接序列化，然后对应到 Object，所以这种情况下，就需要自己产生 ID，而自己生成 ID 的话，就有很多限制，比如需要根据时间递增，尽量比较短，在分布式的情况下 ID 保证不能重复等等，本文会">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-12T08:32:08.732Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UID Generator">
<meta name="twitter:description" content="UID Generator为什么要使用由于 Event Soucing 是记录事件的，那么 Object Id 肯定就不能是用数据库生成的了，基本上所有的 Event Soucing 相关的框架都是将事件直接序列化，然后对应到 Object，所以这种情况下，就需要自己产生 ID，而自己生成 ID 的话，就有很多限制，比如需要根据时间递增，尽量比较短，在分布式的情况下 ID 保证不能重复等等，本文会">
  
    <link rel="alternate" href="/atom.xml" title="搜办小组" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">搜办小组</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-UID-Generator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/10/UID-Generator/" class="article-date">
  <time datetime="2019-06-10T13:07:40.000Z" itemprop="datePublished">2019-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      UID Generator
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UID-Generator"><a href="#UID-Generator" class="headerlink" title="UID Generator"></a>UID Generator</h2><h3 id="为什么要使用"><a href="#为什么要使用" class="headerlink" title="为什么要使用"></a>为什么要使用</h3><p>由于 Event Soucing 是记录事件的，那么 Object Id 肯定就不能是用数据库生成的了，基本上所有的 Event Soucing 相关的框架都是将事件直接序列化，然后对应到 Object，所以这种情况下，就需要自己产生 ID，而自己生成 ID 的话，就有很多限制，比如需要根据时间递增，尽量比较短，在分布式的情况下 ID 保证不能重复等等，本文会比较几种方案，然后选择一种比较好的来实现。</p>
<h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>这种方案其实就是基于数据库的自增 ID，各个分布式系统通过一个数据库去分配 ID，由于依赖了数据库，性能肯定是个问题，如果部署多点数据库，不但实现麻烦，而且性能还是取决于数据库数量，所以在分布式系统当中，并发量大的系统一般不会采取该方案。</p>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID是通用唯一识别码 (Universally Unique Identifier)，是由一组 32 位数的 16 进制数字所构成，也就是 128 bit。在规范字符串格式中，UUID 的十六个八位字节被表示为 32个十六进制（基数16）数字，以连字号分隔的五组来显示，形式为 8-4-4-4-12，总共有 36个字符（即三十二个英数字母和四个连字号）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123e4567-e89b-12d3-a456-426655440000</span><br><span class="line">xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>N那个位置，只会是8,9,a,b， M那个位置，代表版本号，由于UUID的标准实现有5个版本，所以只会是1,2,3,4,5。不同的版本基于的算法不一样，而在 Java 中最常用的 <figure class="highlight plain"><figcaption><span>是基于版本 4 的，基于随机数，也会有重复的概率，只是概率特别低，低到几乎可以忽略而已。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">由于这种算法生成的 ID 是字符串，而且长度有特别的长，非常不利于建立索引等操作，所以通常不会用来作为主键。</span><br><span class="line"></span><br><span class="line">#### Snowflake</span><br><span class="line">为了满足在分布式系统中可以生成全局唯一且趋势递增的 ID，Twitter 推出了一种算法，该算法由 64 bit 组成。</span><br><span class="line"></span><br><span class="line">![](https://note.youdao.com/yws/api/personal/file/WEB494d8493f3a2635c4dda26380c3ee06a?method=download&amp;shareKey=ee740e662e59ad62b907200f6c1aac26)</span><br><span class="line"></span><br><span class="line">* 第一位永远是0，实际上这是为了让生成的 ID 都为正数，以保证趋势递增；</span><br><span class="line">* 后面 41 位用来记录时间，理论上可以记录 2^41 毫秒，2^41/(24 * 3600 * 365 * 1000) = 69.7 年，所以这里的理论最大使用时间就是 70 年左右；</span><br><span class="line">* 在后面 10 位用来记录机器 ID ，更准确的应该说是实例 ID，对应的可以是某个 Container 或者某个进程，最多支持 1024 个；</span><br><span class="line">* 最后12位用来记录序列号，来保证每个实例每毫秒生成的 ID 唯一；</span><br><span class="line"></span><br><span class="line">该算法的优点：</span><br><span class="line"></span><br><span class="line">* 不依赖数据库，高性能；</span><br><span class="line">* 生成的 ID 趋势递增；</span><br><span class="line">* 64 bit 的数字作为 ID 相比 UUID 短的多，方便建立数据库索引。</span><br><span class="line"></span><br><span class="line">该算法的缺点：</span><br><span class="line"></span><br><span class="line">* 依赖系统时钟，如果系统时钟发生回拨，那么有可能造成 ID 冲突或乱序。</span><br><span class="line"></span><br><span class="line">### 基于 Java 的实现</span><br><span class="line">基于上面的分析，这里我们选择使用 Snowflake 来实现，Twitter 官方提供了一个[ Scala 版本的实现](https://github.com/twitter/snowflake/tree/scala_28)，在这里我们实现一个 Java 版本，具体代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Slf4j</span><br><span class="line">public class SnowFlake &#123;</span><br><span class="line"></span><br><span class="line">    private static class TimeBackwardsException extends RuntimeException &#123;</span><br><span class="line">        public TimeBackwardsException(String message) &#123;</span><br><span class="line">            super(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 起始的时间戳</span><br><span class="line">     */</span><br><span class="line">    private static final long START_STAMP = 1262275200000L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分占用的位数</span><br><span class="line">     */</span><br><span class="line">    private static final long SEQUENCE_BIT = 12; //序列号占用的位数</span><br><span class="line">    private static final long MACHINE_BIT = 10;   //机器标识占用的位数</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分的最大值</span><br><span class="line">     */</span><br><span class="line">    private static final long MAX_MACHINE_NUM = -1L ^ (-1L &lt;&lt; MACHINE_BIT);</span><br><span class="line">    private static final long MAX_SEQUENCE = -1L ^ (-1L &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 每一部分向左的位移</span><br><span class="line">     */</span><br><span class="line">    private static final long MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">    private static final long TIMESTAMP_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line"></span><br><span class="line">    private long machineId;     //机器标识</span><br><span class="line">    private long sequence = 0L; //序列号</span><br><span class="line">    private long lastStamp = -1L;//上一次时间戳</span><br><span class="line"></span><br><span class="line">    public SnowFlake(long machineId) &#123;</span><br><span class="line"></span><br><span class="line">        if (machineId &gt; MAX_MACHINE_NUM || machineId &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;machineId can&apos;t be greater than MAX_MACHINE_NUM or less than 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.machineId = machineId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 产生下一个ID</span><br><span class="line">     */</span><br><span class="line">    public synchronized Long nextId() &#123;</span><br><span class="line">        long currStamp = getNewStamp();</span><br><span class="line">        if (currStamp &lt; lastStamp) &#123;</span><br><span class="line">            throw new TimeBackwardsException(&quot;Clock moved backwards.  Refusing to generate id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (currStamp == lastStamp) &#123;</span><br><span class="line">            sequence = (sequence + 1) &amp; MAX_SEQUENCE;</span><br><span class="line"></span><br><span class="line">            //同一毫秒的序列数已经达到最大</span><br><span class="line">            if (sequence == 0L) &#123;</span><br><span class="line">                sequence = new Random().nextInt(10);</span><br><span class="line">                currStamp = getNextMill();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 新的一毫秒，随机从 0-9 中开始</span><br><span class="line">            sequence = new Random().nextInt(10);</span><br><span class="line">        &#125;</span><br><span class="line">        lastStamp = currStamp;</span><br><span class="line"></span><br><span class="line">        return (currStamp - START_STAMP) &lt;&lt; TIMESTAMP_LEFT //时间戳部分</span><br><span class="line">            | machineId &lt;&lt; MACHINE_LEFT             //机器标识部分</span><br><span class="line">            | sequence;                             //序列号部分</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNextMill() &#123;</span><br><span class="line">        long mill = getNewStamp();</span><br><span class="line">        while (mill &lt;= lastStamp) &#123;</span><br><span class="line">            mill = getNewStamp();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return mill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private long getNewStamp() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细阅读以下这段代码，你会发现有个地方和我们描述的不太一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (currStamp == lastStamp) &#123;</span><br><span class="line">    sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同一毫秒的序列数已经达到最大</span></span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">        sequence = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">        currStamp = getNextMill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新的一毫秒，随机从 0-9 中开始</span></span><br><span class="line">    sequence = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再毫秒刷新的时候，我们并没有去把序列号置为 0，而是随机从 0-9 取了一个数，这么做的原因是在并发量不是特别高的时候，如果都从 0 开始的话，会导致生成的 ID 都是偶数，那么在做一些分表操作的时候，会导致严重的分配不均匀，所以这里我们随机从 0-9 开始让产生的 ID 尽可能的分配均匀。但是这么做是会下降性能的，每毫秒的 ID 生成数量会下降一些，但是这并没有下降数量级，完全是可以接受的。</p>
<h3 id="基于-Spring-Cloud-分配-Worker-Id"><a href="#基于-Spring-Cloud-分配-Worker-Id" class="headerlink" title="基于 Spring Cloud 分配 Worker Id"></a>基于 Spring Cloud 分配 Worker Id</h3><p>上面介绍了如何使用 Snowflake 来生成 ID，那么结合 Spring Cloud ，我们需要给每个节点分配一个 Worker ID，但是由于 Spring Cloud 的特点，它是希望每个节点无状态化的，这就给我们分配 Worker ID 带来了一定的难度，如果我们需要区分每个几点，就不得不将节点信息存储到某个中央，然后再分配，为了便于之后的水平扩展，这里我们基于内部代码实现，大概的原理是在服务启动的时候，记录下节点 IP 和 MAC ，作为 Service Node Key 存储到数据库，这个 Key 在数据库中唯一，通过这个唯一的 Key 给不同的节点分配 ID。下面我们尝试使用 JPA 来实现这一过程。</p>
<p>**Spring Cloud 在 2.1.0 之后提供了 <figure class="highlight plain"><figcaption><span>方法，但是可以为空，所以需要看各个具体实现，我看了 K8S 和 consul 都提供了该方法的实现**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">@Entity</span><br><span class="line">@Getter</span><br><span class="line">@Setter</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class WorkerId &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(unique = true)</span><br><span class="line">    private String serviceKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public interface WorkerIdRepository extends JpaRepository&lt;WorkerId, Long&gt; &#123;</span><br><span class="line">    WorkerId findByServiceKey(String serviceKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Slf4j</span><br><span class="line">public class WorkerIdService &#123;</span><br><span class="line"></span><br><span class="line">    private final WorkerIdRepository workerIdRepository;</span><br><span class="line">    private final Registration registration;</span><br><span class="line"></span><br><span class="line">    Long getWorkerId() &#123;</span><br><span class="line"></span><br><span class="line">        String serviceKey = getServiceKey();</span><br><span class="line"></span><br><span class="line">        WorkerId workerId = workerIdRepository.findByServiceKey(serviceKey);</span><br><span class="line"></span><br><span class="line">        if (workerId != null) &#123;</span><br><span class="line">            return workerId.getId() % (SnowFlake.MAX_MACHINE_NUM + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        workerId = new WorkerId();</span><br><span class="line">        // 如果你的 Spring Boot 版本 &gt;= 2.1.0 并且使用的 Discovery 提供了该方法的实现则可以直接使用</span><br><span class="line">        // workerId.setServiceKey(registration.getInstanceId());</span><br><span class="line">        workerId.setServiceKey(serviceKey);</span><br><span class="line">        workerIdRepository.save(workerId);</span><br><span class="line">        return workerId.getId() % (SnowFlake.MAX_MACHINE_NUM + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 由于 Spring Cloud Discovery 的 ServiceInstance 接口没有一个获取 instance id 的方法，所以只能想办法自己标记</span><br><span class="line">     * Spring Cloud Discovery 在 2.1.0 之后的版本在接口中提供了 getInstanceId 这一方法，但是可以为空，所以需要各个实现，我看了 K8S 和 consul 都提供了该方法的实现</span><br><span class="line">     * @return ip:mac_address 形式的字符串</span><br><span class="line">     */</span><br><span class="line">    public String getServiceKey() &#123;</span><br><span class="line">        byte[] mac = null;</span><br><span class="line">        String hostAddress = null;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            while (networkInterfaces.hasMoreElements()) &#123;</span><br><span class="line">                NetworkInterface networkInterface = networkInterfaces.nextElement();</span><br><span class="line">                Enumeration&lt;InetAddress&gt; addresses = networkInterface.getInetAddresses();</span><br><span class="line"></span><br><span class="line">                while (addresses.hasMoreElements()) &#123;</span><br><span class="line">                    InetAddress addr = addresses.nextElement();</span><br><span class="line">                    if (addr instanceof Inet4Address &amp;&amp; !addr.isLoopbackAddress() &amp;&amp; (networkInterface.getDisplayName().equals(&quot;en0&quot;) || networkInterface.getDisplayName().equals(&quot;eth0&quot;))) &#123;</span><br><span class="line">                        hostAddress = addr.getHostAddress();</span><br><span class="line">                        mac = networkInterface.getHardwareAddress();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mac != null &amp;&amp; StringUtils.isNotBlank(hostAddress)) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        if (mac == null || StringUtils.isBlank(hostAddress)) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        // mac地址拼装成String</span><br><span class="line">        StringBuilder macAddress = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; mac.length; i++) &#123;</span><br><span class="line">            if (i != 0) &#123;</span><br><span class="line">                macAddress.append(&quot;-&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            //mac[i] &amp; 0xFF 是为了把byte转化为正整数</span><br><span class="line">            String s = Integer.toHexString(mac[i] &amp; 0xFF);</span><br><span class="line">            macAddress.append(s.length() == 1 ? 0 + s : s);</span><br><span class="line">        &#125;</span><br><span class="line">        // 把字符串所有小写字母改为大写成为正规的mac地址并返回</span><br><span class="line">        return hostAddress + &quot;:&quot; + macAddress.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立相应的 Entity、Repository、Service，从代码中可以看到 Worker ID 的实现，获取 IP 和 MAC 作为唯一 Key 存入数据库，获取到自增 ID，然后对 Snowflake 的最大 Worker ID 取余，这样便得到了一个可用的 Worker ID。</p>
<p>然而这么做会不会有问题？由于Worker ID 在 0-1023 之间反复，如果某些节点反复重启，超过 1024 次并且一些节点一直没有重启，就会出现 Worker ID 重复的情况。由于我们的业务目前节点的更新一般都是逐个依次重启，所以这里暂时不去处理这个问题，未来如果需要多个节点进行 AB 测试，这个时候可能就会出现某些节点频繁更新，而某些节点不变化的情况，届时可能就要重新考虑分配 ID 的方案了。</p>
<p>下面继续完成上面的方案，我们已经写好了相关的 Service ，剩下的就是在服务启动的时候向数据库写入信息了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIDGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WorkerIdService workerIdService;</span><br><span class="line">    <span class="keyword">private</span> SnowFlake flake;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UIDGenerator</span><span class="params">(WorkerIdService workerIdService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerIdService = workerIdService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flake.nextId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flake = <span class="keyword">new</span> SnowFlake(workerIdService.getWorkerId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们建立一个 <code>UIDGenerator</code> 作为服务的 ID 生成器，在启动的时候，通过 <code>WorkerIdService</code> 获取到一个 Worker ID，并构建 <code>Snowfalke</code> 对象，至此我们的 ID 生成器就基本完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/10/UID-Generator/" data-id="cjwsz7bag000afz1dw6x513j8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/">CQRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Event-Sourcing/">Event Sourcing</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UUID/">UUID</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/11/实现-Event-Sourcing/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          实现 Event Sourcing
        
      </div>
    </a>
  
  
    <a href="/2019/06/10/Event-Sourcing-And-CQRS/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Event Sourcing And CQRS</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Axon/">Axon</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CQRS/">CQRS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Event-Sourcing/">Event Sourcing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UUID/">UUID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Axon/" style="font-size: 15px;">Axon</a> <a href="/tags/CQRS/" style="font-size: 15px;">CQRS</a> <a href="/tags/Event-Sourcing/" style="font-size: 20px;">Event Sourcing</a> <a href="/tags/UUID/" style="font-size: 10px;">UUID</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/12/深入使用-Axon/">深入使用 Axon</a>
          </li>
        
          <li>
            <a href="/2019/06/11/实现CQRS/">实现CQRS</a>
          </li>
        
          <li>
            <a href="/2019/06/11/实现-Event-Sourcing/">实现 Event Sourcing</a>
          </li>
        
          <li>
            <a href="/2019/06/10/UID-Generator/">UID Generator</a>
          </li>
        
          <li>
            <a href="/2019/06/10/Event-Sourcing-And-CQRS/">Event Sourcing And CQRS</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Jokefaker<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>